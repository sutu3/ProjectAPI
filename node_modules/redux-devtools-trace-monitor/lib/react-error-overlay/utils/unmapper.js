"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unmap = unmap;
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _stackFrame = _interopRequireDefault(require("./stack-frame"));

var _getSourceMap = require("./getSourceMap");

var _getLinesAround = require("./getLinesAround");

var _path = _interopRequireDefault(require("path"));

/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function count(search, string) {
  // Count starts at -1 becuse a do-while loop always runs at least once
  var count = -1,
      index = -1;

  do {
    // First call or the while case evaluated true, meaning we have to make
    // count 0 or we found a character
    ++count; // Find the index of our search string, starting after the previous index

    index = string.indexOf(search, index + 1);
  } while (index !== -1);

  return count;
}
/**
 * Turns a set of mapped <code>StackFrame</code>s back into their generated code position and enhances them with code.
 * @param {string} fileUri The URI of the <code>bundle.js</code> file.
 * @param {StackFrame[]} frames A set of <code>StackFrame</code>s which are already mapped and missing their generated positions.
 * @param {number} [fileContents=3] The number of lines to provide before and after the line specified in the <code>StackFrame</code>.
 */


function unmap(_x, _x2) {
  return _unmap.apply(this, arguments);
}

function _unmap() {
  _unmap = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_fileUri, frames) {
    var contextLines,
        fileContents,
        fileUri,
        map,
        _args = arguments;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            contextLines = _args.length > 2 && _args[2] !== undefined ? _args[2] : 3;
            fileContents = (0, _typeof2["default"])(_fileUri) === 'object' ? _fileUri.contents : null;
            fileUri = (0, _typeof2["default"])(_fileUri) === 'object' ? _fileUri.uri : _fileUri;

            if (!(fileContents == null)) {
              _context.next = 7;
              break;
            }

            _context.next = 6;
            return fetch(fileUri).then(function (res) {
              return res.text();
            });

          case 6:
            fileContents = _context.sent;

          case 7:
            _context.next = 9;
            return (0, _getSourceMap.getSourceMap)(fileUri, fileContents);

          case 9:
            map = _context.sent;
            return _context.abrupt("return", frames.map(function (frame) {
              var functionName = frame.functionName,
                  lineNumber = frame.lineNumber,
                  columnNumber = frame.columnNumber,
                  _originalLineNumber = frame._originalLineNumber;

              if (_originalLineNumber != null) {
                return frame;
              }

              var fileName = frame.fileName;

              if (fileName) {
                // The web version of this module only provides POSIX support, so Windows
                // paths like C:\foo\\baz\..\\bar\ cannot be normalized.
                // A simple solution to this is to replace all `\` with `/`, then
                // normalize afterwards.
                fileName = _path["default"].normalize(fileName.replace(/[\\]+/g, '/'));
              }

              if (fileName == null) {
                return frame;
              }

              var fN = fileName;
              var source = map.getSources() // Prepare path for normalization; see comment above for reasoning.
              .map(function (s) {
                return s.replace(/[\\]+/g, '/');
              }).filter(function (p) {
                p = _path["default"].normalize(p);
                var i = p.lastIndexOf(fN);
                return i !== -1 && i === p.length - fN.length;
              }).map(function (p) {
                return {
                  token: p,
                  seps: count(_path["default"].sep, _path["default"].normalize(p)),
                  penalties: count('node_modules', p) + count('~', p)
                };
              }).sort(function (a, b) {
                var s = Math.sign(a.seps - b.seps);

                if (s !== 0) {
                  return s;
                }

                return Math.sign(a.penalties - b.penalties);
              });

              if (source.length < 1 || lineNumber == null) {
                return new _stackFrame["default"](null, null, null, null, null, functionName, fN, lineNumber, columnNumber, null);
              }

              var sourceT = source[0].token;

              var _map$getGeneratedPosi = map.getGeneratedPosition(sourceT, lineNumber, // $FlowFixMe
              columnNumber),
                  line = _map$getGeneratedPosi.line,
                  column = _map$getGeneratedPosi.column;

              var originalSource = map.getSource(sourceT);
              return new _stackFrame["default"](functionName, fileUri, line, column || null, (0, _getLinesAround.getLinesAround)(line, contextLines, fileContents || []), functionName, fN, lineNumber, columnNumber, (0, _getLinesAround.getLinesAround)(lineNumber, contextLines, originalSource));
            }));

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _unmap.apply(this, arguments);
}

var _default = unmap;
exports["default"] = _default;