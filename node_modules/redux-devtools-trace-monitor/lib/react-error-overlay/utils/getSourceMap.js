"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractSourceMapUrl = extractSourceMapUrl;
exports.getSourceMap = getSourceMap;
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _sourceMap = require("source-map");

/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * A wrapped instance of a <code>{@link https://github.com/mozilla/source-map SourceMapConsumer}</code>.
 *
 * This exposes methods which will be indifferent to changes made in <code>{@link https://github.com/mozilla/source-map source-map}</code>.
 */
var SourceMap = /*#__PURE__*/function () {
  function SourceMap(sourceMap) {
    (0, _classCallCheck2["default"])(this, SourceMap);
    (0, _defineProperty2["default"])(this, "__source_map", void 0);
    this.__source_map = sourceMap;
  }
  /**
   * Returns the original code position for a generated code position.
   * @param {number} line The line of the generated code position.
   * @param {number} column The column of the generated code position.
   */


  (0, _createClass2["default"])(SourceMap, [{
    key: "getOriginalPosition",
    value: function getOriginalPosition(line, column) {
      var _this$__source_map$or = this.__source_map.originalPositionFor({
        line: line,
        column: column
      }),
          l = _this$__source_map$or.line,
          c = _this$__source_map$or.column,
          s = _this$__source_map$or.source;

      return {
        line: l,
        column: c,
        source: s
      };
    }
    /**
     * Returns the generated code position for an original position.
     * @param {string} source The source file of the original code position.
     * @param {number} line The line of the original code position.
     * @param {number} column The column of the original code position.
     */

  }, {
    key: "getGeneratedPosition",
    value: function getGeneratedPosition(source, line, column) {
      var _this$__source_map$ge = this.__source_map.generatedPositionFor({
        source: source,
        line: line,
        column: column
      }),
          l = _this$__source_map$ge.line,
          c = _this$__source_map$ge.column;

      return {
        line: l,
        column: c
      };
    }
    /**
     * Returns the code for a given source file name.
     * @param {string} sourceName The name of the source file.
     */

  }, {
    key: "getSource",
    value: function getSource(sourceName) {
      return this.__source_map.sourceContentFor(sourceName);
    }
  }, {
    key: "getSources",
    value: function getSources() {
      return this.__source_map.sources;
    }
  }]);
  return SourceMap;
}();

function extractSourceMapUrl(fileUri, fileContents) {
  var regex = /\/\/[#@] ?sourceMappingURL=([^\s'"]+)\s*$/gm;
  var match = null;

  for (;;) {
    var next = regex.exec(fileContents);

    if (next == null) {
      break;
    }

    match = next;
  }

  if (!(match && match[1])) {
    return Promise.reject("Cannot find a source map directive for ".concat(fileUri, "."));
  }

  return Promise.resolve(match[1].toString());
}
/**
 * Returns an instance of <code>{@link SourceMap}</code> for a given fileUri and fileContents.
 * @param {string} fileUri The URI of the source file.
 * @param {string} fileContents The contents of the source file.
 */


function getSourceMap(_x, _x2) {
  return _getSourceMap.apply(this, arguments);
}

function _getSourceMap() {
  _getSourceMap = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee( //function getSourceMap(
  fileUri, fileContents) {
    var sm, base64, match2, index, url, obj;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return extractSourceMapUrl(fileUri, fileContents);

          case 2:
            sm = _context.sent;

            if (!(sm.indexOf('data:') === 0)) {
              _context.next = 14;
              break;
            }

            base64 = /^data:application\/json;([\w=:"-]+;)*base64,/;
            match2 = sm.match(base64);

            if (match2) {
              _context.next = 8;
              break;
            }

            throw new Error('Sorry, non-base64 inline source-map encoding is not supported.');

          case 8:
            sm = sm.substring(match2[0].length);
            sm = window.atob(sm);
            sm = JSON.parse(sm);
            return _context.abrupt("return", new SourceMap(new _sourceMap.SourceMapConsumer(sm)));

          case 14:
            index = fileUri.lastIndexOf('/');
            url = fileUri.substring(0, index + 1) + sm;
            _context.next = 18;
            return fetch(url).then(function (res) {
              return res.json();
            });

          case 18:
            obj = _context.sent;
            return _context.abrupt("return", new SourceMap(new _sourceMap.SourceMapConsumer(obj)));

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getSourceMap.apply(this, arguments);
}

var _default = getSourceMap;
exports["default"] = _default;