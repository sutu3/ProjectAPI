"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tooltip = tooltip;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _ramda = require("ramda");

var _utils = _interopRequireDefault(require("./utils"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var prependClass = _utils.default.prependClass,
    functor = _utils.default.functor;
var defaultOptions = {
  left: undefined,
  // mouseX
  top: undefined,
  // mouseY
  offset: {
    left: 0,
    top: 0
  },
  root: undefined
};

function tooltip(d3) {
  var className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'tooltip';
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var _ref = _objectSpread(_objectSpread({}, defaultOptions), options),
      left = _ref.left,
      top = _ref.top,
      offset = _ref.offset,
      root = _ref.root;

  var attrs = {
    class: className
  };

  var text = function text(node) {
    return '';
  };

  var styles = {};
  var el;
  var anchor = root || d3.select('body');
  var rootNode = anchor.node();

  function tip(selection) {
    selection.on('mouseover.tip', function (node) {
      var _d3$mouse = d3.mouse(rootNode),
          _d3$mouse2 = (0, _slicedToArray2.default)(_d3$mouse, 2),
          mouseX = _d3$mouse2[0],
          mouseY = _d3$mouse2[1];

      var x = left || mouseX + offset.left,
          y = top || mouseY - offset.top;
      anchor.selectAll("div.".concat(className)).remove();
      el = anchor.append('div').attr(prependClass(className)(attrs)).style(_objectSpread({
        position: 'absolute',
        'z-index': 1001,
        left: "".concat(x, "px"),
        top: "".concat(y, "px")
      }, styles)).html(function () {
        return text(node);
      });
    });
    selection.on('mousemove.tip', function (node) {
      var _d3$mouse3 = d3.mouse(rootNode),
          _d3$mouse4 = (0, _slicedToArray2.default)(_d3$mouse3, 2),
          mouseX = _d3$mouse4[0],
          mouseY = _d3$mouse4[1];

      var x = left || mouseX + offset.left,
          y = top || mouseY - offset.top;
      el.style({
        left: "".concat(x, "px"),
        top: "".concat(y, "px")
      }).html(function () {
        return text(node);
      });
    });
    selection.on('mouseout.tip', function () {
      return el.remove();
    });
  }

  tip.attr = function setAttr(d) {
    if ((0, _ramda.is)(Object, d)) {
      attrs = _objectSpread(_objectSpread({}, attrs), d);
    }

    return this;
  };

  tip.style = function setStyle(d) {
    if ((0, _ramda.is)(Object, d)) {
      styles = _objectSpread(_objectSpread({}, styles), d);
    }

    return this;
  };

  tip.text = function setText(d) {
    text = functor(d);
    return this;
  };

  return tip;
}